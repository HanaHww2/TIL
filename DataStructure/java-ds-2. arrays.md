# Arrays

- 배열의 마지막에 새로운 요소를 추가하거나 마지막 요소를 제거하는 경우의 **시간 복잡도는 O(1)** 이다. ( addLast(), removeLast() )
- 배열의 앞 부분에서 새로운 요소를 추가하거나, 삭제하는 경우의 **시간 복잡도는 O(n)** 이다. ( addFirst(), removeFirst() )
    - 배열의 요소들은 메모리 상에 순차적으로 저장된다.
    - 추가의 경우, 기존 요소들을 한 칸씩 뒤로 이동시켜 새로운 요소를 삽입할 공간을 만들어야 한다.
    - 삭제의 경우, 요소를 삭제한 뒤 생긴 빈 공간으로 남은 요소들을 한 칸씩  앞으로 옮겨와야 한다.

### Unordered Arrays

배열에서 순서를 신경쓰지 않는 경우도 있을 수 있다. 배열의 순서가 의미가 없게 된다.

상수 시간 O(1)으로 배열의 앞에서 새로운 요소를 추가, 삭제할 수 있다.

- 배열의 앞 부분에 새로운 요소를 추가하는 경우, 기존 배열의 첫번째 요소를 가장 마지막으로 이동시킨다.
- 배열의 첫번째 요소를 삭제하는 경우, 기존 배열의 마지막 요소를 가장 앞 칸으로 이동시킨다.

# 배열을 이용한 스택/큐

순서가 있는 보편적 배열을 활용할 수 있다.

### 스택 Stack

addLast(), removeLast() 를 활용할 수 있다. 시간 복잡도 O(1)이므로, 상수 시간으로 작업할 수 있다.

### 큐 Queue

addFirst(), removeLast() 를 활용할 수 있다. 시간 복잡도가 각각 O(n), O(1)이므로 효율이 좋지는 않다.

시간 복잡도와 고정 크기 등과 같은 배열 특유의 구조로 인해서, 스택과 큐를 구현할 때 배열을 사용하지는 않는다.

# Circular Arrays

- 배열의 양쪽 끝이 연결되어 있다.
- 배열이 비어있는 경우, head와 tail 포인터는 배열의 중앙을 가리킨다.
- 배열이 비어있거나, 가득 찼을 때, head와 tail이 같은 곳을 가리킨다.
    - 배열의 크기 변수를 사용하여, 배열에 있는 요소 개수를 확인해 배열이 비었는지, 가득 차 있는지 구분할 수 있다.
- 상수 시간 복잡도로 배열에 추가/제거 작업을 할 수 있다. ( addLast(), removeLast(), addFirst(), removeFirst() )
- 최초에 요구되는 것보다 더 큰 사이즈로 배열이 할당되어야 한다는 단점이 있다.

파이썬Python 혹은 펄Perl과 같은 언어들에서 다루는 배열의 형태이다.

`❓ python에서 list 구조(아마도 배열)에서 pop(-1)은 O(n)의 시간 복잡도를 갖는 것으로 알고 있다???
deque와 같은 자료구조를 얘기하는 것인 듯?`

# 연결 리스트와 비교

tail 포인터가 없는 연결 리스트에서 맨 뒤에서 추가/삭제하는 작업의 시간 복잡도가 O(n)이다. (배열과는 반대)

### 배열 vs. 연결 리스트
type|pros|cons
:--:|:--|:--
배열|실제로 더 빠르다. <br> 메모리를 덜 차지한다.|크기가 고정되어 있다. <br> 만약 배열의 크기가 다 차게 되면, 2배 사이즈의 배열을 다시 할당해 배열 요소를 모두 복사해 옮겨야 한다. 그러므로 배열을 적절한 크기로 만들 필요가 있다.<br> 즉, 데이터의 잦은 추가로 인한 배열 크기의 빠른 증가는 비싼 비용을 초래한다.
연결리스트|크기가 정해져 있지 않다.|더 느리다.<br> 메모리를 더 차지한다. (next 포인터)